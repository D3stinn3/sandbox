#!/usr/bin/env bash
set -euo pipefail

#####################
# Script constants. #
#####################
export COMPOSE_PROJECT_NAME="${COMPOSE_PROJECT_NAME:-algorand-sandbox}"
DEFAULT_CONFIG='release'
SANDBOX_DIR=$(dirname "$0")
source "$SANDBOX_DIR/.env"
CLEAN_FILE="$SANDBOX_DIR/.clean"
ACTIVE_CONFIG_FILE="$SANDBOX_DIR/.active_config"
SANDBOX_LOG="$SANDBOX_DIR/sandbox.log"
FAST_CATCHUP_URL='https://algorand-catchpoints.s3.us-east-2.amazonaws.com/channel/CHANNEL/latest.catchpoint'
USE_FAST_CATCHUP=1
INTERACTIVE_MODE=0
VERBOSE_MODE=0

#########################
# Config file variables #
#########################
export ALGOD_CHANNEL=""
export ALGOD_URL=""
export ALGOD_BRANCH=""
export ALGOD_SHA=""
export NETWORK=""
export NETWORK_BOOTSTRAP_URL=""
export NETWORK_GENESIS_FILE=""
export NODE_ARCHIVAL=""
export INDEXER_URL=""
export INDEXER_BRANCH=""
export INDEXER_SHA=""
export INDEXER_DISABLED=""

##################################################
# Determine the correct docker command (or fail) #
##################################################
if [ -x "$(command -v docker-compose)" ]; then
  DOCKER_COMPOSE="docker-compose"
elif [ "$(docker compose help &>/dev/null; echo "$?")" -eq 16 ]; then
  DOCKER_COMPOSE="docker compose"
else
  echo 'Error: docker compose is not installed.' >&2
  exit 1
fi

######################################
# Compatibility with Windows / MSYS2 #
######################################

# All commands that use a TTY/pseudo-TTY
# need to be prefixed by "$WINDOWS_PTY_PREFIX"
WINDOWS_PTY_PREFIX=
if [ "$(uname)" == "Darwin" ]; then
  true
elif [ "$(expr substr $(uname -s) 1 10)" == "MINGW32_NT" ] || \
     [ "$(expr substr $(uname -s) 1 10)" == "MINGW64_NT" ]; then
  WINDOWS_PTY_PREFIX="winpty"
fi

#########################
# Helpers and utilities #
#########################

# Console colorized print helpers
default="\033[0m"

red="\033[0;31m"
green="\033[0;32m"
blue="\033[0;34m"
teal="\033[0;36m"

# bold
Bgreen="\033[1;32m"


function printc () {
  printf "$1$2${default}\n"
}

function statusline () {
  printc "${Bgreen}" "\n$1"
}

function err_noexit () {
  printf "${red}$1${default}\n"
}

function err () {
  err_noexit "$1"
  exit 1
}

# Overwrite the current line on the terminal
function overwrite() {
  echo -e "\r\033[1A\033[0K$@";
}

# Interactive yes/no prompt
function ask () {
    # https://djm.me/ask
    local prompt default reply

    if [ "${2:-}" = "Y" ]; then
        prompt="Y/n"
        default=Y
    elif [ "${2:-}" = "N" ]; then
        prompt="y/N"
        default=N
    else
        prompt="y/n"
        default=
    fi

    while true; do

        # Ask the question (not using "read -p" as it uses stderr not stdout)
        echo -n "$1 [$prompt] "

        # Read the answer (use /dev/tty in case stdin is redirected from somewhere else)
        read reply </dev/tty

        # Default?
        if [ -z "$reply" ]; then
            reply=$default
        fi

        # Check if the reply is valid
        case "$reply" in
            Y*|y*) return 0 ;;
            N*|n*) return 1 ;;
        esac

    done
}

# Spinner - https://stackoverflow.com/a/20369590
# Show a spinner for long running commands:
#   (command) & spinner
function spinner()
{
  local pid=$!
  local delay=0.75
  local spinstr='|/-\'
  while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do
    local temp=${spinstr#?}
    overwrite " [${spinstr::1}] "
    local spinstr=$temp${spinstr%"$temp"}
    sleep $delay
  done
  overwrite ""
}

# Progress bar - https://stackoverflow.com/a/28044986
# 1. Create progress_bar function
# 1.1 Input is prefixString($1) currentState($2) and totalState($3)
function progress_bar {
  local progress
  local done
  local left
  local fill
  local empty

  # Process data
  progress=$(( $(( ${2} * 100 / ${3} * 100)) / 100))
  done=$(( $(( ${progress} * 4 )) / 10 ))
  left=$(( 40 - $done ))

  # Build progressbar string lengths
  fill=$(printf "%${done}s")
  empty=$(printf "%${left}s")

  # 1.2 Build progressbar strings and print the progress_bar line
  # 1.2.1 Output example:
  # 1.2.1.1 Progress : [****************************************] 100%
  overwrite "$1 : [${fill// /â–‡}${empty// / }] [$2/$3] ${progress}%"
}

###################################################################
# Sandbox function containing worker functions to execute commands.
###################################################################

sandbox () {
  status_helper () {
    source_chosen_config_file "${@-}"
    status_helper_core
  }
  status_helper_core () {
    APORT="${ALGOD_PORT:-4001}"
    KPORT="${KMD_PORT:-4002}"
    IPORT="${INDEXER_PORT:-8980}"

    statusline "algod - goal node status"
    goal_helper_config $CHOSEN_CONFIG node status
    statusline "indexer - health"
    curl -s "localhost:$IPORT/health?pretty"
  }

  # docker-compose alias
  # must only be used when no pseudo-TTY is required
  # in particular, when using 
  #   dc ... exec ...
  # the flag -T needs to be passed
  # Concretely, to execute non-interactive commands:
  #   dc exec -T algod goal node status
  # and if the command is interactive, dc_pty needs to be used:
  #   dc_pty algod exec //bin/bash
  # This is to ensure compatibility with Windows Msys
  dc () {
    VERBOSE_FLAG=""
    if [ $VERBOSE_MODE == 1 ]; then
      # --verbose is universally available since tag https://github.com/docker/compose-cli/releases/tag/v1.0.18 pr https://github.com/docker/compose-cli/pull/1830
      VERBOSE_FLAG=" --verbose"
    fi

    $DOCKER_COMPOSE$VERBOSE_FLAG -f "$SANDBOX_DIR/docker-compose.yml" "$@"
  }

  # dc_pty needs to be used instead of dc any time
  # a pseudo-TTY is required.
  # See comment of dc ()
  # Do NOT used when the command input/output needs to be piped
  # or inside command substituions as this will fail on Windows Msys
  dc_pty () {
    # note: cannot be replaced by $WINDOWS_PTY_PREFIX dc "$@"
    #       because winpty requires an executable as argument
    # TODO: can windows docker handle --verbose?
    $WINDOWS_PTY_PREFIX $DOCKER_COMPOSE -f "$SANDBOX_DIR/docker-compose.yml" "$@"
  }

  # Submit a goal command into the chosen configurations.
  # It assumes the command is non-interactive and does not use a pseudo-TTY
  # (option -T)
  goal_helper () {
    source_active_config_file_or_err
    if [ ! -f "$CONFIG_FILE" ]; then
      err "Could not find config file for '$CHOSEN_CONFIG' ($CONFIG_FILE)."
    fi
    statusline "Issuing goal command $@ using $CHOSEN_CONFIG ($CONFIG_FILE) configuration with composed services project name ${COMPOSE_PROJECT_NAME}"
    dc exec -T algod goal "$@"
  }
  goal_helper_config () {
    source_chosen_config_file "${@-}"
    shift 
    # Require the active or default configuration be present to send commands to goal.
    if [ ! -f "$CONFIG_FILE" ]; then
      err "Could not find config file for '$CHOSEN_CONFIG' ($CONFIG_FILE)."
    fi
    statusline "Issuing goal command ${@-} using $CHOSEN_CONFIG ($CONFIG_FILE) configuration with composed services project name ${COMPOSE_PROJECT_NAME}"
    dc exec -T algod goal "${@:-}"
  }

  # A shortcut for isssuing tealdbg commands to the chosen configuration
  # It assumes the command is non-interactive and does not use a pseudo-TTY
  # (option -T)
  tealdbg_helper_blank () {
    source_active_config_file_or_err
    tealdbg_helper $@
  }
  tealdbg_helper_config () {
    source_chosen_config_file "${@-}"
    shift
    tealdbg_helper $@
  }
  tealdbg_helper () {
    statusline "Issuing tealdbg command $@ using $CHOSEN_CONFIG configuration with composed services project name ${COMPOSE_PROJECT_NAME}"

    if [[ "$*" == *--listen* ]]
    then
        dc exec -T algod tealdbg "$@"
    else
      if [[ "$*" == *debug* ]]
      then
          echo "tealdbg debug command called without --listen option therefore sandbox attached the option automatically!"
          dc exec -T algod tealdbg  "$@" --listen 0.0.0.0
          
      else
          dc exec -T algod tealdbg "$@"
      fi        
    fi    
  }

  # Wait until indexer/algod health endpoints report 200.  Assumes CHOSEN_CONFIG has been set and sourced prior to calling.
  wait_for_services() {
    local ATTEMPTS_REMAINING=60
    local INDEXER_STATUS="000"
    local ALGOD_STATUS="000"

    APORT="${ALGOD_PORT:-4001}"
    KPORT="${KMD_PORT:-4002}"
    IPORT="${INDEXER_PORT:-8980}"

    # wait for startup
    while [[ $ATTEMPTS_REMAINING -gt 0 ]]; do
      INDEXER_STATUS=$(curl -sL -w "%{http_code}\n" "localhost:$IPORT/health" -o /dev/null || true)
      ALGOD_STATUS=$(curl -sL -w "%{http_code}\n" "localhost:$APORT/health" -o /dev/null || true)
      if [ "$ALGOD_STATUS" == "200" ] && [ "$INDEXER_STATUS" == "200" ]; then
        ATTEMPTS_REMAINING=0
      else
        ((ATTEMPTS_REMAINING--))
        sleep 1
      fi
    done

    if [ "$ALGOD_STATUS" != "200" ] || [ "$INDEXER_STATUS" != "200" ]; then
      echo "The following service container did not start:"
      if [ "$ALGOD_STATUS" != "200" ]; then
        echo "- algod (the algorand node)"
      fi
      if [ "$INDEXER_STATUS" != "200" ]; then
        echo "- indexer"
      fi
      err "One or more services failed to start."
    fi
  }

  # Print out the versions of the services running in the chosen configuration.
  version_helper () {
    source_chosen_config_file "${@-}"
    version_helper_core
  }
  version_helper_core () {
    APORT="${ALGOD_PORT:-4001}"
    KPORT="${KMD_PORT:-4002}"
    IPORT="${INDEXER_PORT:-8980}"

    statusline "Now checking the versions of the containers for $CHOSEN_CONFIG configuration with composed services project name ${COMPOSE_PROJECT_NAME}"

    echo "algod version"
    dc exec -T algod goal -v
    echo "Indexer version"
    INDEXER_VERSION=$(dc exec -T indexer cmd/algorand-indexer/algorand-indexer daemon -v) && echo ${INDEXER_VERSION} || curl -s "localhost:$IPORT/health?pretty"
    echo "Postgres version"
    dc exec -T indexer-db postgres -V
  }

  # Given a network name attempts to fetch a catchpoint and catchup for the chosen configuration.
  perform_fast_catchup () {
    goal_helper_config $CHOSEN_CONFIG node catchup "$1"

    if [ $? -ne 0 ]; then
      err "There was a problem starting fast catchup."
    fi

    # Newline for the progress bar to use.
    echo ""
    DONE=false
    STARTED=false
    while [ $DONE == "false" ]; do
      sleep 0.1

      local RES
      local TOTAL
      local PROGRESS

      RES="$(status_helper_core)"
      TOTAL=1000
      PROGRESS=0

      # If progress has been made, update the progress.
      if [[ "$RES" == *"Catchpoint total accounts"* ]]; then
        STARTED=true
        TOTAL=$(echo $RES | grep -o 'Catchpoint total accounts: [[:digit:]]*' | cut -d':' -f 2 )
        PROGRESS=$(echo $RES | grep -o 'Catchpoint accounts processed: [[:digit:]]*' | cut -d':' -f 2 )
      elif [ $STARTED == "true" ]; then
        DONE=true
        PROGRESS=$TOTAL
      fi

      if [ $TOTAL == $PROGRESS ]; then
        DONE=true
      else
        progress_bar "Processing accounts:" "$PROGRESS" "$TOTAL"
      fi
    done

    overwrite "Account processing complete."

    # Newline for the progress bar to use.
    echo ""

    DONE=false
    STARTED=false
    while [ $DONE == "false" ]; do
      sleep 0.1

      local RES
      local TOTAL
      local PROGRESS

      RES="$(status_helper_core)"
      TOTAL=1000
      PROGRESS=0

      # If progress has been made, update the progress.
      if [[ "$RES" == *"Catchpoint downloaded blocks"* ]]; then
        STARTED=true
        TOTAL=$(echo $RES | grep -o 'Catchpoint total blocks: [[:digit:]]*' | cut -d ':' -f 2 )
        PROGRESS=$(echo $RES | grep -o 'Catchpoint downloaded blocks: [[:digit:]]*' | cut -d ':' -f 2 )
      elif [ $STARTED == "true" ]; then
        DONE=true
        PROGRESS=$TOTAL
      fi

      if [ $TOTAL == $PROGRESS ]; then
        DONE=true
      else
        progress_bar "Downloading blocks:" "$PROGRESS" "$TOTAL"
      fi
    done

    # Clear progress bar line and print success text.
    overwrite "Blocks downloaded."

    sleep 1
  }

  # Copy files into and out of the chosen configuration.
  copyTo () {
    source_active_config_file_or_err
    statusline "Now copying $1 to Algod container in /opt/data/$1 using $CHOSEN_CONFIG configuration with composed services project name ${COMPOSE_PROJECT_NAME}"
    docker cp "$1" "$(dc ps -q algod):/opt/data/$(basename $1)"
  }
  copyTo_config () {
    source_chosen_config_file "${@-}"
    shift
    statusline "Now copying $1 to Algod container in /opt/data/$1 using $CHOSEN_CONFIG configuration with composed services project name ${COMPOSE_PROJECT_NAME}"
    docker cp "$1" "$(dc ps -q algod):/opt/data/$(basename $1)"
  }
  copyFrom () {
    source_active_config_file_or_err
    statusline "Now copying  /opt/data/$1 from Algod container to $SANDBOX_DIR/ using $CHOSEN_CONFIG with composed services project name ${COMPOSE_PROJECT_NAME}"  
    docker cp "$(dc ps -q algod):/opt/data/$(basename $1)" "$1"
  }
  copyFrom_config () {
    source_chosen_config_file "${@-}"
    shift
    statusline "Now copying  /opt/data/$1 from Algod container to $SANDBOX_DIR/ using $CHOSEN_CONFIG with composed services project name ${COMPOSE_PROJECT_NAME}"  
    docker cp "$(dc ps -q algod):/opt/data/$(basename $1)" "$1"
  }

  # Clean a given configuration.
  clean () {
    source_chosen_config_file "${@-}"
    if [ ! -f "$CONFIG_FILE" ]; then
      err "Could not find config file for '$CHOSEN_CONFIG' ($CONFIG_FILE)."
    fi
    statusline "Cleaning $CHOSEN_CONFIG configuration with composed services project name ${COMPOSE_PROJECT_NAME}"

    echo "Running docker-compose down -t 0"
    dc down -t 0                                   || true
    echo "Running docker-compose rmi ${COMPOSE_PROJECT_NAME}-algod ${COMPOSE_PROJECT_NAME}-indexer"
    docker rmi ${COMPOSE_PROJECT_NAME}-algod ${COMPOSE_PROJECT_NAME}-indexer                   || true
    rm "$ACTIVE_CONFIG_FILE" > /dev/null 2>&1                  || true
    echo 'clean function executed' > "$CLEAN_FILE.$CHOSEN_CONFIG";
  }

  # The enter command attaches users to a shell in the desired configuration's service.
  enter_config () {
    source_chosen_config_file "${@-}"
    shift
    enter "${@-}" 
  }
  enter_blank () {
    source_active_config_file_or_err
    enter "${@-}"
  }
  enter () {
    statusline "Entering $CHOSEN_CONFIG configuration with composed services project name ${COMPOSE_PROJECT_NAME}"

    CONTAINER=${1:-}
    if [ -z "$CONTAINER" ]; then
        err "'enter' requires a container. Available containers: algod, indexer, indexer-db"
    fi
    case $CONTAINER in
      algod)
        statusline "Entering /bin/bash session in the algod container..."
        dc_pty exec algod //bin/bash
        return
        ;;
      indexer)
        statusline "Entering /bin/bash session in the indexer container..."
        dc_pty exec indexer //bin/bash
        return
        ;;
      indexer-db)
        statusline "Entering /bin/bash session in the indexer-db container..."
        dc_pty exec indexer-db //bin/bash
        return
        ;;
    esac

    err "Cannot enter '$CONTAINER'. Available containers: algod, indexer, indexer-db"
  }


  # Stream the logs from the algod container in the specified configuration to the shell.
  logs () {
    source_chosen_config_file "${@-}"
    statusline "Streaming logs from $CHOSEN_CONFIG configuration with composed services project name ${COMPOSE_PROJECT_NAME}"
    
    if [[ $# -gt 1 && $2 == "raw" ]]; then
      dc exec -T algod tail -f node.log
    else
      # We need a PTY with carpenter to have colors
      dc_pty exec algod carpenter -D
    fi
  }

  # Restart the configuration specified by marking it down, removing all the containers, and bringing it back up with fast-catchup (if not disabled).
  restart () {
    source_chosen_config_file "${@-}"
    statusline "Restarting $CHOSEN_CONFIG configuration with composed services project name ${COMPOSE_PROJECT_NAME}"

    down "$CHOSEN_CONFIG"
    dc rm -f

    # up only runs fast-catchup for fresh installs.
    # removing the active config file will trick it.
    rm -f "$ACTIVE_CONFIG_FILE" > /dev/null 2>&1 || true

    sandbox up "$CHOSEN_CONFIG" "$@"
  }

  # Figure out what the chosen configuration should be by looking at the active configuration or choosing the default configuration.  
  # Sets CHOSEN_CONFIG, ACTIVE_CONFIG and CONFIG_FILE.
  # Errors if the chosen configuration file is not on the filesystem.
  source_active_config_file_or_err () {
    # Grab active config if there is one
    ACTIVE_CONFIG="" 
    CHOSEN_CONFIG=""
    if [ -f "$ACTIVE_CONFIG_FILE" ]; then
      CHOSEN_CONFIG=$(cat $ACTIVE_CONFIG_FILE)
      ACTIVE_CONFIG=$(cat $ACTIVE_CONFIG_FILE)
    fi
    if [ -z $CHOSEN_CONFIG ]; then
      err "No active configuration file."
    fi
    
    CONFIG_FILE="$SANDBOX_DIR/config.$CHOSEN_CONFIG"

    # Error if config does not exist.
    if [ ! -f "$CONFIG_FILE" ]; then
      err "Could not find active configuration file for config $CHOSEN_CONFIG $CONFIG_FILE "
    else
      source "$CONFIG_FILE"
    fi
  }

  # Figure out what the chosen configuration should be by looking at the first argument to the function, 
  # then to the active configuration if blank, and then to the default configuration if nothing is active.
  # Sets CHOSEN_CONFIG, CONFIG_FILE, and ACTIVE_CONFIG.
  source_chosen_config_file () {
    # Grab active config if there is one
    ACTIVE_CONFIG=""
    if [ -f "$ACTIVE_CONFIG_FILE" ]; then
      ACTIVE_CONFIG=$(cat $ACTIVE_CONFIG_FILE)
    fi

    # Initialize new config, accounting for no-argument down command.
    if [ "$1" = "" ]; then
      if [ ! -z $ACTIVE_CONFIG ]; then
        CHOSEN_CONFIG="$ACTIVE_CONFIG"
      else
        CHOSEN_CONFIG="$DEFAULT_CONFIG"
      fi
    else
      CHOSEN_CONFIG="$1"
    fi
    CONFIG_FILE="$SANDBOX_DIR/config.$CHOSEN_CONFIG"

    # Warn if config does not exist, then use default project name
    if [ ! -f "$CONFIG_FILE" ]; then
      echo "Warning:  Could not find config file for '$CHOSEN_CONFIG'."
    else
      source "$CONFIG_FILE"
    fi
    
  }

  # Stop the configuration specified.
  down () {
      source_chosen_config_file "${@-}"
      dc stop -t 0

  }

  # Run some tests on the configuration specified.
  test () {
      source_chosen_config_file "${@-}"
      statusline "Test command for project ${COMPOSE_PROJECT_NAME} forwarding..."
      APORT="${ALGOD_PORT:-4001}"
      KPORT="${KMD_PORT:-4002}"
      IPORT="${INDEXER_PORT:-8980}"

      printc $default "~$ ${blue}docker exec -it algod uname -a"
      dc exec -T algod uname -a

      TOKEN=$(cat "$SANDBOX_DIR/config/token")
      statusline "Test Algod REST API..."
      printc $default "~$ ${blue}curl ${teal}localhost:$APORT/v2/status?pretty -H \"X-Algo-API-Token: $TOKEN\""
      curl "localhost:$APORT/v2/status?pretty" -H "X-Algo-API-Token: $TOKEN"

      statusline "Test KMD REST API..."
      printc $default "~$ ${blue}curl ${teal}localhost:$KPORT/v1/wallets -H \"X-KMD-API-Token: $TOKEN\""
      curl "localhost:$KPORT/v1/wallets" -H "X-KMD-API-Token: $TOKEN"

      statusline "\nTest Indexer REST API..."
      printc $default "~$ ${blue}curl ${teal}\"localhost:$IPORT/health?pretty\""
      curl "localhost:$IPORT/health?pretty"
  }

  # Helper utility to get the latest catchpoint for fast-catchup ( used in up() )
  set_catchpoint () {
    # TODO: Might be useful to allow providing the catchpoint with '-c'
    CATCHPOINT=$(curl -s ${FAST_CATCHUP_URL/CHANNEL/$1})
    # If the catchpoint wasn't returned there is a multiline error.
    if [[ "$(echo $CATCHPOINT | wc -l | tr -d ' ')" != "1" ]]; then
      CATCHPOINT=""
    fi
  }

  # Helper utility to build the chosen configuration if the clean file is present ( used in up() ).
  rebuild_if_needed () {
    if [ -f "$CLEAN_FILE.$CHOSEN_CONFIG" ]; then
      rm "$CLEAN_FILE.$CHOSEN_CONFIG"
      statusline ".clean file for $CHOSEN_CONFIG found in sandbox directory. Rebuilding images for configuration $CHOSEN_CONFIG in ${COMPOSE_PROJECT_NAME}..."
      echo "Running docker-compose build --no-cache"
      dc build --no-cache
    else 
      FRESH_INSTALL=0
    fi
  }

  check_port () {
    if ( $(nc -z localhost $1 > /dev/null 2>&1 ) ) 
    then
      echo "Looks like this localhost already has something operating on the "
      echo "port '$CHOSEN_CONFIG''s $2 wants to use ($1)."
      if ask "Do you want to proceed?" "Y"; then
        echo "Okay, proceeding."
      else
         err "$2 wants to use unavailable port $1.  This port was checked for availability using nc -z localhost $1"
      fi
    fi
  }
 
  check_ports () {
    check_port "${ALGOD_PORT:-4001}" "algod(algorand_node)"
    check_port "${KMD_PORT:-4002}" "kmd(key_management)"
    check_port "${INDEXER_PORT:-8980}" "indexer"
    check_port "${CDT_PORT:-9392}" "cdt(chrome_dev_tool)"
    check_port "${POSTGRES_PORT:-9392}" "postgres"
  }

  # Bring the configuration up.
  up () {
      FRESH_INSTALL=1
      source_chosen_config_file "${@-}"

      # Error if configuration file is missing. 
      CONFIG_FILE="$SANDBOX_DIR/config.$CHOSEN_CONFIG"
      if [ ! -f "$CONFIG_FILE" ]; then
        SANDBOX_CONFIG_OPTIONS=$(ls "$SANDBOX_DIR"/config.* | sed 's/^.*config\./ /'| paste -sd',' -)
        err "Could not find config file for '$CHOSEN_CONFIG'.\nValid options:$SANDBOX_CONFIG_OPTIONS"
      fi

      # Set the active configuration. 
      echo "$CHOSEN_CONFIG" > "$ACTIVE_CONFIG_FILE"
      source "$CONFIG_FILE"

      statusline "Starting $CHOSEN_CONFIG configuration with composed services project name ${COMPOSE_PROJECT_NAME}"

      # Check if the docker project is already running.
      declare -i projectnames
      projectnames=$(dc ls -q | grep -cFx $COMPOSE_PROJECT_NAME || true)
      if [ ! $projectnames == 0 ]; then
        echo It looks like a docker project named ${COMPOSE_PROJECT_NAME} is already running.
        if ask "Do you want to stop it and then bring it up using config : ($CHOSEN_CONFIG)?" "Y"; then
           down $CHOSEN_CONFIG
           if ask "Do you want to clean out the images too?" "Y"; then
             clean $CHOSEN_CONFIG
           fi
        else
          err "Docker project file ${COMPOSE_PROJECT_NAME} is already running"
        fi
      fi

      # Handle mismatched argument + active config
      if [ ! -z "$ACTIVE_CONFIG" ] && [ "$CHOSEN_CONFIG" != "$ACTIVE_CONFIG" ]; then
        echo "The requested configuration is not currently the active configuration."
        echo "$ACTIVE_CONFIG $CHOSEN_CONFIG"
        if ask "Do you want to stop the active config $(ACTIVE_CONFIG) first?" "Y"; then
          down $ACTIVE_CONFIG
          if ask "$ACTIVE_CONFIG has been stopped.  Do you want to clean out its images too?" "Y"; then
            clean $ACTIVE_CONFIG
          fi
        fi

        # Remove the active config file as the user has abandoned (possibly stopped, possibly cleaned) the current 
        # active configuration, and re-run up with the desired configuration.
        rm "$ACTIVE_CONFIG_FILE" > /dev/null 2>&1 || true

        up "$@"
        return
      fi

      # Check if the ports in the config are available
      check_ports

      # Rebuild the images if the .clean file for the configuration has been marked, and then start them with
      # docker-compose up
      if [ $INTERACTIVE_MODE == 1 ]; then
        rebuild_if_needed
        dc convert  >> "$SANDBOX_LOG"
        dc up
      elif [ $VERBOSE_MODE == 0 ]; then
        dc convert  >> "$SANDBOX_LOG"
        rebuild_if_needed >> "$SANDBOX_LOG" 2>&1
        dc up -d  >> "$SANDBOX_LOG" 2>&1 & spinner
      else
        dc convert  >> "$SANDBOX_LOG"
        dc up -d
      fi

      if [ $FRESH_INSTALL == 0 ]; then
        echo "Sandbox determined that this config '$CHOSEN_CONFIG' did not need a image rebuild."
      else
        echo "Sandbox rebuilt the images for '$CHOSEN_CONFIG'."
      fi

      echo -e "Waiting for ${COMPOSE_PROJECT_NAME} to initialize."
      wait_for_services
      echo "Services ready!"

      version_helper_core
      status_helper_core

      if [ -z $NETWORK_GENESIS_FILE ]; then
        # Print wallet information
        goal_helper wallet -f unencrypted-default-wallet > /dev/null 2>&1

        ACCOUNTS_OUTPUT=$(goal_helper account list)
        for acct in $(echo "$ACCOUNTS_OUTPUT" | cut -f 3 |tr -s ' '); do
          ACCOUNTS+=($acct)
        done

        statusline "Available accounts"
        printc $default "~$ ${blue}./sandbox ${teal}goal account list"
        echo "$ACCOUNTS_OUTPUT"
        statusline "Example command to send between two accounts:"
        printc $default "~$ ${blue}./sandbox ${teal}goal clerk send -a 123456789 -f ${ACCOUNTS[1]} -t ${ACCOUNTS[2]}"
        statusline "Soon after sending the transaction it will appear in indexer:"
        printc $default "~$ ${blue}curl ${teal}\"localhost:$IPORT/v2/transactions?pretty\""
      else
        # Attempt fast catchup (if not disabled on the command line)
        if [ $USE_FAST_CATCHUP == 1 ] && [ $FRESH_INSTALL == 1 ] && [ ! -z "$NETWORK" ]; then
          set_catchpoint $NETWORK

          if [ -z $CATCHPOINT ]; then
            err_noexit "Fast catchup is not available for $NETWORK, continuing without catchup."
          else
            statusline "Starting fast-catchup with catchpoint: $CATCHPOINT"

            perform_fast_catchup $CATCHPOINT

            statusline "Fast-catchup complete"
            status_helper_core
          fi
        else
          statusline "Skipping fast catchup"
        fi
      fi
  }

  # Print out some helpful information.
  help () {
      cat <<-EOF
Algorand Sandbox

Sandbox manages a set of docker components that contain the algod, indexer, 
and indexerdb(postgres) services.  

Options for the services, including the port numbers, algorand network name,
and details on how and where to pull/build the service images are available 
in the configuration files, which live in the root directory of the sandbox. 

These configuration files are sourced by the sandbox to import the variables 
they define.  In addition, a blank .env file in the root directory is 
sourced by all configurations as a convenience.

Multiple sandbox configurations can be started in parallel. Sandbox 
maintains a notion of the "active" configuration, which is the most recent 
configuration "start"ed, or the configuration set by the "set-active" command.
If a configuration is not specified, the default action is to use the active 
configuration.  If no configuration is active, the default configuration 
will be used (currently set to '$DEFAULT_CONFIG').

In order to bring up, say, both betanet and mainnet on the same machine, 
users will have to provide distinct port numbers and COMPOSE_PROJECT_NAME in 
the two configuration files.  Once they are both started, users can point 
client code to the relevant ports specified to hit either betanet or mainnet. 

sandbox commands:
  <up|start|resume> [config] [-v|--verbose] [-s|--skip_fast_catchup] 
                             [-i|--interactive]
      Start the sandbox docker project defined in the config, and set it as the 
      active configuration. If blank, it will starts the active configuration, 
      or failing that, default to the release configuration.  -v verbose output
      when starting the docker project.  -s flag skips fast catchup if the user
      is starting a non-private network and wish to skip fast cathcup.  -i flag 
      start the docker project in interactive mode.

  <down|pause|stop> [config] 
      Stop the sandbox docker project defined in the config. If blank, it will
      stop the active configuration, or failing that, default to the release 
      configuration.

  <reset|restart> [config] 
      Stop and then start the sandbox docker project defined in the config
      provided. If blank, it will restart the active configuration, or failing
      that, will try to restart the default $DEFAULT_CONFIG configuration.  If
      the chosen configuration points to a non-private network, it will 
      attempt fast-catchup on restart.

  clean [config]
      Stops and deletes the specified sandbox docker project configuration 
      images and containers.  If no configuration provided, the active or the 
      default configuration is cleaned.

  set-active <config>  
      Set the active configuration to <config>.  Config file must be present.

  test [config]
      Runs some tests to demonstrate usage on the specified configuration
      (or on the active configuration, or if none, the default configuration).

  enter <algod||indexer||indexer-db>
      Enter the sandbox container.  Attempts to use the active configuration,
      and if not present, will default to the release configuration.

  enter-config <config> <algod||indexer||indexer-db>
      Enter the sandbox container using the specific config provided.

  version [config] 
      Print binary versions of the specified config, or if unspecified, the
      active (or if nothing is active, the default) configuration.

  active
      Print out the active configuration, if there is one, and quit.

  copyTo <file>
      Copy <file> into the active (or if none, the default) configuration's
      algod /opt/data. Useful for offline transactions, offline LogicSigs and
      TEAL work

  copyFrom <file>
      Copy <file> from /opt/data/ in the active or default configuration algod.
     Useful for offline transactions, offline LogicSigs and TEAL work.

  copyTo-config <config> <file> 
      Copy <file> into the algod in the specific config's /opt/data. Useful
      for offline transactions, offline LogicSigs and TEAL work.

  copyFrom-config <config> <file> 
      Copy <file> from the algod in the specific configuration's /opt/data. 
      Useful for offline transactions, offline LogicSigs and TEAL work.

  logs [config]
      Stream algorand logs with the carpenter utility.

  status [config]
      Get node status of the configuration specified (or the active 
      configuration, or the default configuration).

  goal (args)
      Run goal command like 'goal node status' on the active configuration. 
      Errors if there is no active configuration.

  goal-config <config> (args) 
      Run goal command like 'goal node status' for the specified configuration.

  tealdbg (args) 
      Run tealdbg command on the active configuration.  Errors if there is no
      active configuration.

  tealdbg-config <config> (args) 
      Run tealdbg command for the specified configuration.

EOF
  }

  ####################################################
  # Sandbox function command line parsing begins here.

  if [ $# -eq 0 ]; then
    help
    exit 1
  fi

  case $1 in
    start|up|resume)
      # Remove "up"
      shift

      # Process flags
      PARAMS=()
      while (( "$#" )); do
        case "$1" in
          -v|--verbose)
            VERBOSE_MODE=1
            ;;
          -s|--skip-fast-catchup)
            USE_FAST_CATCHUP=0
            ;;
          -i|--interactive)
            statusline "Note: interactive mode is incompatible with fast-catchup."
            INTERACTIVE_MODE=1
            ;;
          *) # preserve positional arguments
            PARAMS+=("$1")
            ;;
        esac
        shift
      done

      # Call up with remaining parameters
      up "${PARAMS[@]-}"
      ;;

    set-active)
      shift
      if [ "${1-}" = "" ]; then
        err "Must specify a configuration file to set active."
      else
        CONFIG_FILE="$SANDBOX_DIR/config.$1"
        if [ -f "$CONFIG_FILE" ]; then
          statusline "Setting active configuration to $1"
          echo "$1" > "$ACTIVE_CONFIG_FILE" 
        else
          SANDBOX_CONFIG_OPTIONS=$(ls "$SANDBOX_DIR"/config.* | sed 's/^.*config\./ /'| paste -sd',' -)
          err "Could not find config file for $1.\nValid options:$SANDBOX_CONFIG_OPTIONS"
        fi
      fi
      ;;
      
    stop|down|pause)
      shift 
      down "${@-}"
      ;;

    restart|reset)
      shift
      restart "${@-}"
      ;;

    clean)
      # Remove "clean"
      shift
      clean "${@-}" | tee -a "$SANDBOX_LOG" 2>&1
      ;;

    active)
      if [ -f "$ACTIVE_CONFIG_FILE" ]; then
        echo "Active configuration = $(cat $ACTIVE_CONFIG_FILE)"
      else
        echo "There is no active configuration."
        echo "Sandbox commands that do not specify a configuration file will thus be redirected to the default configuration."
        echo "The default configuration is ${DEFAULT_CONFIG}"
      fi
      ;;

    test)
      shift
      test "${@-}"
      ;;

    enter)
      shift
      enter_blank "${@-}"
      ;;

    enter-config)
      shift
      enter_config "${@-}"
      ;;

    logs)
      shift
      logs "${@-}"
      ;;

    status)
      shift
      status_helper "${@-}"
      ;;

    version)
      shift
      version_helper "${@-}"
      ;;

    goal)
      shift
      goal_helper "${@-}"
      ;;

    goal-config)
      shift
      goal_helper_config "${@-}"
      ;;

    tealdbg)
      shift
      tealdbg_helper_blank "${@-}"
      ;;

    tealdbg-config)
      shift
      tealdbg_helper_config "${@-}"
      ;;

    copyTo|cpt)
      shift
      copyTo "${@-}"
      ;;
    copyTo-config|cpt)
      shift
      copyTo_config "${@-}"
      ;;

    copyFrom-config|cpf)
      shift
      copyFrom_config "${@-}"
      ;;
    copyFrom|cpf)
      shift
      copyFrom "${@-}"
      ;;

    bob)
      shift
      check_project_name "${@-}"
      ;;

    *)

      help
      ;;
  esac
}

# Script main program starts here.
sandbox "$@"
